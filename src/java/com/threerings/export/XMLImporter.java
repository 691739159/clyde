//
// $Id$

package com.threerings.export;

import java.io.EOFException;
import java.io.IOException;
import java.io.InputStream;

import java.lang.reflect.Array;
import java.lang.reflect.Constructor;
import java.lang.reflect.Modifier;

import java.util.Collection;
import java.util.HashMap;
import java.util.Map;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.Text;

import com.threerings.util.ReflectionUtil;

import static java.util.logging.Level.*;
import static com.threerings.export.Log.*;

/**
 * Imports from the XML format generated by {@link XMLExporter}.
 */
public class XMLImporter extends Importer
{
    /**
     * Creates an importer to read from the specified stream.
     */
    public XMLImporter (InputStream in)
    {
        _in = in;
    }

    @Override // documentation inherited
    public Object readObject ()
        throws IOException
    {
        Node first;
        if (_document == null) {
            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            try {
                DocumentBuilder builder = factory.newDocumentBuilder();
                _document = builder.parse(_in);
            } catch (Exception e) {
                throw new IOException("Failed to parse input [error=" + e + "].");
            }
            Element top = _document.getDocumentElement();
            if (!top.getTagName().equals("java")) {
                throw new IOException("Invalid top-level element [name=" +
                    top.getTagName() + "].");
            }
            String vstr = top.getAttribute("version");
            if (!vstr.equals(XMLExporter.VERSION)) {
                throw new IOException("Invalid version [version=" + vstr + ", expected=" +
                    XMLExporter.VERSION + "].");
            }
            String cstr = top.getAttribute("class");
            if (!cstr.equals(getClass().getName())) {
                throw new IOException("Invalid importer class [class=" + cstr + ", expected=" +
                    getClass().getName() + "].");
            }
            first = top.getFirstChild();
        } else {
            first = (_element == null) ? null : _element.getNextSibling();
        }
        if ((_element = findElement(first, "object")) == null) {
            throw new EOFException();
        }
        return read(_element, Object.class);
    }

    @Override // documentation inherited
    public boolean read (String name, boolean defvalue)
        throws IOException
    {
        String value = getValue(name);
        return (value == null) ? defvalue : Boolean.parseBoolean(value);
    }

    @Override // documentation inherited
    public byte read (String name, byte defvalue)
        throws IOException
    {
        String value = getValue(name);
        try {
            return (value == null) ? defvalue : Byte.parseByte(value);
        } catch (NumberFormatException e) {
            log.log(WARNING, "Couldn't parse value as byte [value=" + value + "].", e);
            return defvalue;
        }
    }

    @Override // documentation inherited
    public char read (String name, char defvalue)
        throws IOException
    {
        String value = getValue(name);
        return (value == null) ? defvalue : value.charAt(0);
    }

    @Override // documentation inherited
    public double read (String name, double defvalue)
        throws IOException
    {
        String value = getValue(name);
        try {
            return (value == null) ? defvalue : Double.parseDouble(value);
        } catch (NumberFormatException e) {
            log.log(WARNING, "Couldn't parse value as double [value=" + value + "].", e);
            return defvalue;
        }
    }

    @Override // documentation inherited
    public float read (String name, float defvalue)
        throws IOException
    {
        String value = getValue(name);
        try {
            return (value == null) ? defvalue : Float.parseFloat(value);
        } catch (NumberFormatException e) {
            log.log(WARNING, "Couldn't parse value as float [value=" + value + "].", e);
            return defvalue;
        }
    }

    @Override // documentation inherited
    public int read (String name, int defvalue)
        throws IOException
    {
        String value = getValue(name);
        try {
            return (value == null) ? defvalue : Integer.parseInt(value);
        } catch (NumberFormatException e) {
            log.log(WARNING, "Couldn't parse value as int [value=" + value + "].", e);
            return defvalue;
        }
    }

    @Override // documentation inherited
    public long read (String name, long defvalue)
        throws IOException
    {
        String value = getValue(name);
        try {
            return (value == null) ? defvalue : Long.parseLong(value);
        } catch (NumberFormatException e) {
            log.log(WARNING, "Couldn't parse value as long [value=" + value + "].", e);
            return defvalue;
        }
    }

    @Override // documentation inherited
    public short read (String name, short defvalue)
        throws IOException
    {
        String value = getValue(name);
        try {
            return (value == null) ? defvalue : Short.parseShort(value);
        } catch (NumberFormatException e) {
            log.log(WARNING, "Couldn't parse value as short [value=" + value + "].", e);
            return defvalue;
        }
    }

    @Override // documentation inherited
    public <T> T read (String name, T defvalue, Class<T> clazz)
        throws IOException
    {
        Element child = findElement(_element.getFirstChild(), name);
        if (child == null) {
            return defvalue;
        }
        @SuppressWarnings("unchecked") T value = (T)read(child, clazz);
        return value;
    }

    @Override // documentation inherited
    public void close ()
        throws IOException
    {
        _in.close();
    }

    /**
     * Reads an object of the supplied type from the given element.
     */
    protected Object read (Element element, Class clazz)
        throws IOException
    {
        String ref = element.getAttribute("ref");
        if (ref.length() > 0) {
            return _objects.get(ref);
        } else if (element.getFirstChild() == null) {
            return null;
        } else {
            return readValue(element, clazz);
        }
    }

    /**
     * Reads an object value of the specified class from the given element.
     */
    protected Object readValue (Element element, Class<?> clazz)
        throws IOException
    {
        // see if we can read the value from a string
        String id = element.getAttribute("id");
        String cstr = element.getAttribute("class");
        Class<?> cclazz;
        if (cstr.length() > 0) {
            try {
                cclazz = Class.forName(cstr);
            } catch (ClassNotFoundException e) {
                log.log(WARNING, "Class not found.", e);
                return null;
            }
        } else {
            cclazz = clazz;
        }
        Stringifier stringifier = Stringifier.getStringifier(cclazz);
        if (stringifier != null) {
            String string = element.getTextContent();
            Object value = null;
            try {
                if ((value = stringifier.fromString(string)) == null) {
                    log.log(WARNING, "Failed to parse string [string=" + string + ", class=" +
                        cclazz + "].");
                }
            } catch (Exception e) {
                log.log(WARNING, "Failed to parse string [string=" + string + ", class=" +
                    cclazz + "].", e);
            }
            if (id.length() > 0 && value != null) {
                _objects.put(id, value);
            }
            return value;
        }
        // otherwise, process the element
        Element oelement = _element;
        _element = element;
        try {
            Object value;
            if (cclazz.isArray()) {
                String len = element.getAttribute("length");
                value = Array.newInstance(cclazz.getComponentType(), Integer.parseInt(len));
            } else {
                Class<?> eclazz = cclazz.getEnclosingClass();
                value = ReflectionUtil.newInstance(cclazz,
                    (eclazz == null || Modifier.isStatic(cclazz.getModifiers())) ?
                        null : read("outer", null, eclazz));
            }
            if (id.length() > 0) {
                _objects.put(id, value);
            }
            if (value instanceof Exportable) {
                readFields((Exportable)value);
            } else if (value instanceof Object[]) {
                readEntries((Object[])value, cclazz.getComponentType());
            } else if (value instanceof Collection) {
                @SuppressWarnings("unchecked") Collection<Object> collection =
                    (Collection<Object>)value;
                readEntries(collection);
            } else if (value instanceof Map) {
                @SuppressWarnings("unchecked") Map<Object, Object> map =
                    (Map<Object, Object>)value;
                readEntries(map);
            }
            return value;

        } finally {
            _element = oelement;
        }
    }

    /**
     * Populates the supplied array with the entries under the current element.
     */
    protected void readEntries (Object[] array, Class<?> cclazz)
        throws IOException
    {
        int idx = 0;
        for (Node node = _element.getFirstChild(); node != null; node = node.getNextSibling()) {
            if (node instanceof Element && node.getNodeName().equals("entry")) {
                array[idx++] = read((Element)node, cclazz);
            }
        }
    }

    /**
     * Populates the supplied collection with the entries under the current element.
     */
    protected void readEntries (Collection<Object> collection)
        throws IOException
    {
        for (Node node = _element.getFirstChild(); node != null; node = node.getNextSibling()) {
            if (node instanceof Element && node.getNodeName().equals("entry")) {
                collection.add(read((Element)node, Object.class));
            }
        }
    }

    /**
     * Populates the supplied map with the entries under the current element.
     */
    protected void readEntries (Map<Object, Object> map)
        throws IOException
    {
        for (Node node = _element.getFirstChild(); node != null; node = node.getNextSibling()) {
            if (node instanceof Element && node.getNodeName().equals("key")) {
                Object key = read((Element)node, Object.class);
                for (node = node.getNextSibling(); node != null; node = node.getNextSibling()) {
                    if (node instanceof Element && node.getNodeName().equals("value")) {
                        map.put(key, read((Element)node, Object.class));
                        break;
                    }
                }
            }
        }
    }

    /**
     * For simple text fields, retrieves the value from a child element.
     */
    protected String getValue (String name)
    {
        Element child = findElement(_element.getFirstChild(), name);
        if (child == null) {
            return null;
        }
        for (Node node = child.getFirstChild(); node != null; node = node.getNextSibling()) {
            if (node instanceof Text) {
                return node.getNodeValue();
            }
        }
        return null;
    }

    /**
     * Finds the first element in the sibling chain with the given name.
     */
    protected static Element findElement (Node first, String name)
    {
        for (Node node = first; node != null; node = node.getNextSibling()) {
            if (node instanceof Element && node.getNodeName().equals(name)) {
                return (Element)node;
            }
        }
        return null;
    }

    /** The source stream. */
    protected InputStream _in;

    /** The parsed XML document. */
    protected Document _document;

    /** The element associated with the current object. */
    protected Element _element;

    /** Mappings from ids to referenced objects. */
    protected HashMap<String, Object> _objects = new HashMap<String, Object>();
}
